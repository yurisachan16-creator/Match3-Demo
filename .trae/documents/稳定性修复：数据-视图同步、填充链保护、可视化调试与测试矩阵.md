# 问题根因分析（基于当前实现）

## 1) “颜色与数据不一致”为什么会发生
- Match3SDK 的匹配判定只看 `HasItem` + `ItemId`（见 [LineDetector.cs](file:///d:/unity/Works/Match3-Demo/Library/PackageCache/com.chebanovdd.match3sdk@0.1.3/Runtime/Match3.Infrastructure/SequenceDetectors/LineDetector.cs#L40-L56)）。
- 当前视图颜色是由 `GameBoardView` 的 `ItemIdToColor` 计算得到，但逻辑上允许 **ItemId 取任意整数**（来自 [ItemsPool.cs](file:///d:/unity/Works/Match3-Demo/Assets/Scripts/Match3/ItemsPool.cs) 的 `availableItemIds`）。
- 如果 `itemIds` 的数量/范围与 `palette` 不一一对应（例如 palette 只有 5 色，但 itemIds 传入了 1..8 或不连续），视图颜色就会出现“同色不同 ID / 同 ID 不同色”的错觉，最终表现为：
  - 玩家视觉认为“颜色相同应该消除”，但实际上 `ItemId` 不同导致判定失败。

## 2) “消除后填充异常”为什么会发生
- 当前流程是：消除动画 -> 清数据 -> 下落补位 -> 生成新元素 -> 连锁。
- 若出现任何一步数据/视图不同步（例如某格 `HasItem=true` 但对应 ItemView 已被回收或颜色未刷新），就会导致“看起来没补位/补位后显示不对”。
- 异常难复现的原因通常是：
  - 随机生成（无固定 seed）导致状态不可重放。
  - 输入/动画/数据更新顺序偶发竞争（例如快速操作、Busy 边界）。

# 解决目标（按你给的 4 点要求对齐）

1. **实现数据-视图双向验证系统**：运行时能检测/定位并可选自动修复。
2. **重构/增强消除判定**：增加一致性检查与自检日志，确保“视觉 = 数据”。
3. **补全异常处理流程**：保证消除链完整，不因局部异常导致卡死/漏补。
4. **提供可视化调试工具**：能在 Scene/Game 中看出每格的 ItemId、状态、异常标记。

# 实施方案（文件级交付物）

## A) 严格颜色编码与数据状态同步（核心）

### A1. 引入“ItemId -> Color”显式映射
- 把现在的 `itemIds + palette` 改为强约束结构：
  - `ItemVisual[]`（每项包含 `itemId` 与 `color`）
- 启动时构建 `Dictionary<int, Color>`，并进行以下校验：
  - `itemId` 去重
  - `color` 可选去重（用于避免“同色不同 ID”）
  - `ItemsPool` 只能从映射表的 key 集合中取值
- `GameBoardView` 颜色渲染不再使用“取模/默认白色兜底”，而是：
  - 找不到映射立即标红 + 记录错误（并可触发自动修复/重建）

### A2. 视图绑定改为“以数据为准”
- 每次 `OnItemChanged` 时，视图只做 1 件事：
  - 依据 `slot.ItemId` 查字典得到颜色，设置到对应 ItemRenderer。
- 增加 `ForceResyncAll()`：完全根据 board 数据重建/纠偏视图（用于异常恢复）。

## B) 数据-视图双向验证系统

### B1. Invariant 校验（每个关键阶段）
在以下节点执行校验（可开关）：
- 每次 Swap 完成后
- 每次 Clear/Collapse/Spawn 完成后
- 每次连锁循环结束后

校验项（最小集）：
- `HasItem == false` -> 该格 ItemView 必须不存在/不可见
- `HasItem == true` -> ItemView 必须存在，且颜色 == `ItemId` 映射色
- 所有 `CanContainItem==true` 的格子在 Fill 完成后不得为空

异常策略：
- 记录日志（含棋盘快照）
- 触发一次 `ForceResyncAll()`
- 若仍不一致，直接 `RebuildBoard()` 进入可恢复状态

### B2. 双向验证（可视化层面）
- 额外提供 Debug Overlay：在每个格子上显示：
  - `ItemId`（数字）
  - mismatch 标记（例如红框/叹号）

## C) 重构/增强消除判定与链完整性

### C1. 增加独立的“简单匹配扫描器”用于交叉验证
- 新增 `SimpleMatchScanner`（不依赖 SDK）：
  - 横向/纵向扫描连续段，找出 >=3 的序列
- 对比 `GameBoardSolver` 的结果：
  - 若结果不一致，打印差异（序列坐标）并标记到 Debug Overlay

### C2. 补位状态机保护
- 在每轮 `Clear -> Collapse -> Spawn` 后做 “是否存在空洞” 检查：
  - 若发现空洞，强制补齐并记录日志（保证不漏补位）
- 连锁次数达到 `maxChains` 时输出告警并停止（避免死循环）。

## D) 可复现测试用例矩阵 + 压测

### D1. 可复现随机
- 修改 `ArrayItemsPool` 支持固定 seed（可从 Inspector 配置），保证同一 seed 可重现。

### D2. 自动化压力测试组件
- 新增 `Match3StabilityTester`（MonoBehaviour）：
  - 用固定 seed 连续做 N 次随机合法交换
  - 每步后跑一次 Invariant 校验
  - 支持边界用例：角落/边缘/无效方向/Busy 时输入等

## E) 调试日志与可视化工具
- 统一 `Match3DebugLogger`（环形缓冲区），记录关键节点：
  - Swap 请求/Swap 结果/是否触发消除
  - Clear 列表
  - Collapse move 列表
  - Spawn 列表
  - Chain 次数
- Inspector 按钮：
  - Dump Snapshot
  - Toggle Overlay
  - Run 100 swaps stress

# 执行顺序（保证每步都可验证）

1. 先做 **颜色-数据严格映射**（解决“看起来相同但实际不等”的根源）。
2. 加 **Invariant 校验 + ForceResyncAll**（把“偶发不同步”变成可定位的确定性日志）。
3. 增加 **SimpleMatchScanner 交叉验证**（定位到底是数据错还是 solver/流程错）。
4. 加 **seed + StressTester**（把难复现问题变成可重放）。
5. 上 **Overlay/按钮/日志**（定位效率倍增）。

确认后我会按上述方案直接落地改代码与调试工具，并以“可复现 seed + 自动压测通过 + 无 mismatch 报告”为验收标准。